## 查询阶段(Query Phase) ##

在查询的初始阶段，查询会被广播(Broadcast)给索引中的每个分片拷贝(Shard Copy，它可以是主分片或者是副本分片)。然后每个分片会在本地执行该搜索，匹配的文档会被保存到一个优先队列(Priority Queue)中。

> **优先队列**
> 
> 优先队列实际上是一个用来保存前N个匹配(Top-N Matching)的文档的有序列表。优先队列的大小取决于分页参数：`from`和`size`。比如，下面的搜索请求会建立一个大小为100的优先队列用于保存匹配的文档：
> 
> ```
> GET /_search
> {
>     "from": 90,
>     "size": 10
> }
> ```

查询阶段的过程如下图所示：

![](http://www.elasticsearch.org/guide/en/elasticsearch/guide/current/images/06-01_query.png)

1. 客户端发送一个搜索请求到节点3，节点3随即会创建一个大小为`from + size`的空的优先队列。
2. 节点3将搜索请求转发到索引中每个分片的主分片(Primary Shard)或副本分片(Replica Shard)。然后每个分片会在本地执行该查询，然后将结果保存到本地的一个大小同样为`from + size`的优先队列中。
3. 每个分片返回优先队列中文档的IDs和它们的排序值到协调节点(Coordinating Node)，也就是节点3。然后节点3负责将所有的结果合并到本地的优先队列中，这个优先队列就是全局的查询结果。

当一个搜索请求被发往一个节点时，该节点就变成了协调节点(Coordinating Node)。它需要向其他关联分片所在的节点广播搜索请求，然后合并来自它们的中间结果来得到最终能够发送给客户端的全局结果。

第一步是将请求广播给索引中所有分片拷贝(可以是主分片，也可以是副本分片)所在的节点。和获取文档的GET请求一样，搜索请求也可以被主分片或者它关联的任意一个副本分片处理。这就是当增加副本分片(添加更多的硬件)能够增加搜索吞吐量的原由。协调节点会通过循环(Round-robin)的方式向所有的分片拷贝发送请求来分布负载。

每个分片会在本地执行查询，然后建立一个大小为`from + size`的优先队列来保存其结果。换言之，在本地就能够满足全局的搜索请求(译注：因为本地的优先队列大小和协调节点上的优先队列大小是一致的)。它会返回一个轻量级的结果列表给协调节点 - 仅包含文档的IDs和在排序过程中需要的相关值，比如`_score`。

协调节点会将从其他节点返回的结果合并来得到一个全局的优先队列。到这里，查询阶段就结束了。

> **多索引搜索(Multi-index Search)**
> 
> 一个索引能够含有一个或者多个主分片，因此针对一个索引的搜索请求需要对来自多个分片的搜索结果进行合并。一个针对多个或者所有索引的搜索请求也以相同的方式工作 - 只是更多的分片会参与到这个过程中。



 






