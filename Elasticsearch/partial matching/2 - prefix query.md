## 前缀查询(Prefix Query) ##

我们可以通过一个简单的prefix查询来得到所有以W1开头的邮政编码：

```json
GET /my_index/address/_search
{
    "query": {
        "prefix": {
            "postcode": "W1"
        }
    }
}
```

prefix查询是一个工作在词条级别的低级查询。它不会在搜索前对查询字符串进行解析。它假设用户会传入一个需要查询的精确前缀。

> **TIP**
> 
> 默认情况下，prefix查询不会计算相关度分值。它只是进行文档匹配，匹配的文档的分值为1。其实，相比查询它更像一个过滤器。prefix查询和prefix过滤器的唯一区别在于过滤器可以被缓存。

之前，我们提到过"你只能找到存在于倒排索引中的词条"，但是对于这些邮政编码我们并没有进行任何特殊处理；每个邮政编码只是被当做精确值被简单地索引。那么prefix查询是如何工作的呢？

记住倒排索引是由唯一词条得有序列表构成的(此种情况下，即邮政编码)。对于每个词条，它会列举所有含有该词条的文档ID。对于我们的示例文档，倒排索引如下所示：

```
Term:          Doc IDs:
-------------------------
"SW5 0BE"    |  5
"W1F 7HW"    |  3
"W1V 3DG"    |  1
"W2F 8HW"    |  2
"WC1N 1LZ"   |  4
-------------------------
```

为了支持前缀匹配，查询会执行以下的步骤：

1. 遍历词条列表并找到以W1开头的词条。
2. 收集对应的文档ID。
3. 移动到下一个词条。
4. 如果该词条也以W1开头，那么重复步骤2；否则结束操作。

尽管以上的步骤对于我们的小例子而言能很好地工作，想象一下当倒排索引含有一百万个以W1开头的邮政编码时的情景，prefix查询需要访问一百万个词条来得到结果。

而前缀越短，就意味着需要访问越多的词条。如果我们查询前缀为W，而不是W1的词条，可能会匹配多达一千万个词条。

> **注意**
> 
> prefix查询和过滤器对于即时(Ad-hoc)的前缀匹配是有用处的，但是在使用它们的时候需要小心。对于拥有少量词条的字段可以随意地使用，但是它们的扩展性较差，可能会让你的集群承受过多的压力。可以通过使用一个较长的前缀来限制它们对于集群的影响；这能够减少需要访问的词条的数量。

在本章的稍后部分，我们会介绍一种让前缀匹配更具效率的索引期间解决方案。但是首先，让我们看看两个相关的查询：wildcard以及regexp查询。