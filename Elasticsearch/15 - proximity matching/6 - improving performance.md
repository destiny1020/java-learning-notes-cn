## 提高性能 ##

短语和邻近度查询比简单的match查询在性能上更昂贵。match查询只是查看词条是否存在于倒排索引(Inverted Index)中，而match_phrase查询则需要计算和比较多个可能重复词条(Multiple possibly repeated)的位置。

在[Lucene Nightly Benchmarks](http://people.apache.org/~mikemccand/lucenebench/)中，显示了一个简单的term查询比一个短语查询快大概10倍，比一个邻近度查询(一个拥有slop的短语查询)快大概20倍。当然，这个代价是在搜索期间而不是索引期间付出的。

> **TIP**
> 
> 通常，短语查询的额外代价并不像这些数字说的那么吓人。实际上，性能上的差异只是说明了一个简单的term查询时多么的快。在标准全文数据上进行的短语查询通常能够在数毫秒内完成，因此它们在实际生产环境下是完全能够使用的，即使在一个繁忙的集群中。
> 
> 在某些特定的场景下，短语查询可能会很耗费资源，但是这种情况时不常有的。一个典型的例子是DNA序列，此时会在很多位置上出现非常之多的相同重复词条。使用高slop值会使位置计算发生大幅度的增长。

因此，如何能够限制短语和邻近度查询的性能消耗呢？一个有用的方法是减少需要使用短语查询进行检查的文档总数。

### 结果的分值重计算(Rescoring Results) ###

在上一节中，我们讨论了使用邻近度查询来调整相关度，而不是使用它来将文档从结果列表中添加或者排除。一个查询可能会匹配百万计的结果，但是我们的用户很可能只对前面几页结果有兴趣。

一个简单的match查询已经通过排序将含有所有搜索词条的文档放在结果列表的前面了。而我们只想对这些前面的结果进行重新排序来给予那些同时匹配了短语查询的文档额外的相关度。

search API通过分值重计算(Rescoring)来支持这一行为。在分值重计算阶段，你能够使用一个更加昂贵的分值计算算法 - 比如一个短语查询 - 来为每个分片的前K个结果重新计算其分值。紧接着这些结果就会按其新的分值重新排序。

该请求如下所示：

```json
GET /my_index/my_type/_search
{
    "query": {
        "match": {  
            "title": {
                "query":                "quick brown fox",
                "minimum_should_match": "30%"
            }
        }
    },
    "rescore": {
        "window_size": 50, 
        "query": {         
            "rescore_query": {
                "match_phrase": {
                    "title": {
                        "query": "quick brown fox",
                        "slop":  50
                    }
                }
            }
        }
    }
}
```

match查询用来决定哪些文档会被包含在最终的结果集合中，结果通过TF/IDF进行排序。
window_size是每个分片上需要重新计算分值的数量。



